# -*- coding: utf-8 -*-
"""projek kripto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zxF-agauLrEEQYM4DU3KOmUQt-IY7iph
"""



# Array S-BOX

# AES S-Box Standar
AES_SBOX = [
    99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,
    202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,
    183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,
    4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,
    9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,
    83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,
    208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,
    81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,
    205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,
    96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,
    224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,
    231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,
    186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,
    112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,
    225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,
    140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22,
]

# SBOX44 (Proposed)
SBOX44 = [
    99,205,85,71,25,127,113,219,63,244,109,159,11,228,94,214,
    77,177,201,78,5,48,29,30,87,96,193,80,156,200,216,86,
    116,143,10,14,54,169,148,68,49,75,171,157,92,114,188,194,
    121,220,131,210,83,135,250,149,253,72,182,33,190,141,249,82,
    232,50,21,84,215,242,180,198,168,167,103,122,152,162,145,184,
    43,237,119,183,7,12,125,55,252,206,235,160,140,133,179,192,
    110,176,221,134,19,6,187,59,26,129,112,73,175,45,24,218,
    44,66,151,32,137,31,35,147,236,247,117,132,79,136,154,105,
    199,101,203,52,57,4,153,197,88,76,202,174,233,62,208,91,
    231,53,1,124,0,28,142,170,158,51,226,65,123,186,239,246,
    38,56,36,108,8,126,9,189,81,234,212,224,13,3,40,64,
    172,74,181,118,39,227,130,89,245,166,16,61,106,196,211,107,
    229,195,138,18,93,207,240,95,58,255,209,217,15,111,46,173,
    223,42,115,238,139,243,23,98,100,178,37,97,191,213,222,155,
    165,2,146,204,120,241,163,128,22,90,60,185,67,34,27,248,
    164,69,41,230,104,47,144,251,20,17,150,225,254,161,102,70,
]

# ===========================================
# Cell 2 — Fungsi dasar AES (manual)
# ===========================================

# Operasi xtime: perkalian dengan 0x02 di GF(2^8)
def xtime(a):
    return ((a << 1) ^ 0x1B) & 0xFF if a & 0x80 else (a << 1) & 0xFF

# Perkalian GF(2^8) general untuk inv_mix_columns
def gmul(a, b):
    p = 0
    for _ in range(8):
        if b & 1:
            p ^= a
        hi = a & 0x80
        a = (a << 1) & 0xFF
        if hi:
            a ^= 0x1B
        b >>= 1
    return p & 0xFF

# Tambah round key = XOR byte ke byte
def add_round_key(state, round_key):
    return [s ^ rk for s, rk in zip(state, round_key)]

# PKCS7 Padding (untuk teks bebas panjang)
def pkcs7_pad(data: bytes, block_size=16) -> bytes:
    pad_len = block_size - (len(data) % block_size)
    return data + bytes([pad_len]) * pad_len

def pkcs7_unpad(data: bytes) -> bytes:
    pad_len = data[-1]
    return data[:-pad_len]

# Helper debug — print state dalam bentuk kotak 4x4
def print_state(state, label="State"):
    print(f"{label}:")
    for i in range(4):
        row = state[i*4:(i+1)*4]
        print(" ".join(f"{x:02X}" for x in row))
    print()

# ===========================================
# Cell 3 — Core AES (untuk AES standar)
# ===========================================

Nb = 4   # block size (4 kolom, 4x4 = 16 byte)
Nk = 4   # key length (4 word = 16 byte)
Nr = 10  # jumlah ronde AES-128

# --------------------------
# 1. Invers S-Box AES
# --------------------------
INV_AES_SBOX = [0] * 256
for i, v in enumerate(AES_SBOX):
    INV_AES_SBOX[v] = i

# --------------------------
# 2. SubBytes & InvSubBytes
# --------------------------
def sub_bytes_aes(state):
    """Substitusi byte menggunakan AES_SBOX."""
    return [AES_SBOX[b] for b in state]

def inv_sub_bytes_aes(state):
    """Substitusi balik menggunakan INV_AES_SBOX."""
    return [INV_AES_SBOX[b] for b in state]

# --------------------------
# 3. ShiftRows & InvShiftRows
# --------------------------
def shift_rows(state):
    """
    Representasi state sebagai array 16 byte:
    [s0, s1, s2, s3, s4, s5, ... s15]
    Dianggap dalam urutan column-major (4x4).
    Implementasi ini mengikuti standard AES.
    """
    return [
        state[0],  state[5],  state[10], state[15],
        state[4],  state[9],  state[14], state[3],
        state[8],  state[13], state[2],  state[7],
        state[12], state[1],  state[6],  state[11],
    ]

def inv_shift_rows(state):
    return [
        state[0],  state[13], state[10], state[7],
        state[4],  state[1],  state[14], state[11],
        state[8],  state[5],  state[2],  state[15],
        state[12], state[9],  state[6],  state[3],
    ]

# --------------------------
# 4. MixColumns & InvMixColumns
# --------------------------
def mix_single_column(col):
    """
    MixColumns untuk 1 kolom (4 byte).
    col: list panjang 4.
    """
    t = col[0] ^ col[1] ^ col[2] ^ col[3]
    u = col[0]
    col[0] ^= t ^ xtime(col[0] ^ col[1])
    col[1] ^= t ^ xtime(col[1] ^ col[2])
    col[2] ^= t ^ xtime(col[2] ^ col[3])
    col[3] ^= t ^ xtime(col[3] ^ u)
    return col

def mix_columns(state):
    """MixColumns untuk seluruh state (16 byte)."""
    state = state[:]  # copy biar tidak in-place ke argumen
    for i in range(0, 16, 4):
        col = state[i:i+4]
        col = mix_single_column(col)
        state[i:i+4] = col
    return state

def inv_mix_columns(state):
    """Inverse MixColumns (pakai gmul)."""
    state = state[:]
    for i in range(0, 16, 4):
        a0, a1, a2, a3 = state[i:i+4]
        state[i+0] = gmul(a0,0x0e) ^ gmul(a1,0x0b) ^ gmul(a2,0x0d) ^ gmul(a3,0x09)
        state[i+1] = gmul(a0,0x09) ^ gmul(a1,0x0e) ^ gmul(a2,0x0b) ^ gmul(a3,0x0d)
        state[i+2] = gmul(a0,0x0d) ^ gmul(a1,0x09) ^ gmul(a2,0x0e) ^ gmul(a3,0x0b)
        state[i+3] = gmul(a0,0x0b) ^ gmul(a1,0x0d) ^ gmul(a2,0x09) ^ gmul(a3,0x0e)
    return state

# --------------------------
# 5. Key Expansion (AES standar)
# --------------------------
Rcon = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36]

def key_expansion_aes(key_bytes: bytes):
    """
    Ekspansi key AES-128:
    - Input: 16 byte (128-bit key)
    - Output: 176 byte (11 round key * 16)
    """
    assert len(key_bytes) == 16, "Key harus 16 byte (AES-128)."

    # Mulai dari key asli (4 word pertama)
    key_schedule = list(key_bytes)

    # Tiap iterasi menghasilkan 4 byte tambahan
    # sampai total 176 byte tercapai
    i = Nk
    while len(key_schedule) < 16 * (Nr + 1):
        temp = key_schedule[-4:]  # 4 byte terakhir

        if i % Nk == 0:
            # RotWord
            temp = temp[1:] + temp[:1]
            # SubWord memakai AES_SBOX
            temp = [AES_SBOX[b] for b in temp]
            # XOR dengan Rcon
            temp[0] ^= Rcon[(i // Nk) - 1]

        # XOR dengan 4 byte ke-16 sebelumnya
        for j in range(4):
            temp[j] ^= key_schedule[-16 + j]

        key_schedule.extend(temp)
        i += 1

    return key_schedule  # list panjang 176 byte

# ===========================================
# Cell 4 — AES standar: enkripsi & dekripsi 1 blok
# ===========================================

def aes_encrypt_block_std(block: bytes, key_bytes: bytes) -> bytes:
    assert len(block) == 16, "Plaintext block harus 16 byte."
    assert len(key_bytes) == 16, "Key harus 16 byte (AES-128)."

    state = list(block)
    round_keys = key_expansion_aes(key_bytes)

    # Initial round
    state = add_round_key(state, round_keys[:16])

    # Main rounds (1-9)
    for rnd in range(1, Nr):
        state = sub_bytes_aes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, round_keys[16*rnd : 16*(rnd+1)])

    # Final round (tanpa MixColumns)
    state = sub_bytes_aes(state)
    state = shift_rows(state)
    state = add_round_key(state, round_keys[160:176])

    return bytes(state)


def aes_decrypt_block_std(block: bytes, key_bytes: bytes) -> bytes:
    assert len(block) == 16, "Ciphertext block harus 16 byte."
    assert len(key_bytes) == 16, "Key harus 16 byte (AES-128)."

    state = list(block)
    round_keys = key_expansion_aes(key_bytes)

    # Initial step of decryption
    state = add_round_key(state, round_keys[160:176])
    state = inv_shift_rows(state)
    state = inv_sub_bytes_aes(state)

    # Rounds 9..1
    for rnd in range(Nr-1, 0, -1):
        state = add_round_key(state, round_keys[16*rnd : 16*(rnd+1)])
        state = inv_mix_columns(state)
        state = inv_shift_rows(state)
        state = inv_sub_bytes_aes(state)

    # Final round key
    state = add_round_key(state, round_keys[:16])
    return bytes(state)


# ----------------------------------------------
# Test manual NIST — Jika mau cek fungsinya
# ----------------------------------------------
def test_aes_block_std():
    key_hex = "000102030405060708090A0B0C0D0E0F"
    pt_hex  = "00112233445566778899AABBCCDDEEFF"
    key = bytes.fromhex(key_hex)
    pt  = bytes.fromhex(pt_hex)

    ct = aes_encrypt_block_std(pt, key)
    dec = aes_decrypt_block_std(ct, key)

    print("Cipher    :", ct.hex().upper())
    print("DecryptOK :", dec.hex().upper() == pt_hex.upper())

test_aes_block_std()

# ===========================================
# Cell 5 — AES SBOX44: enkripsi & dekripsi 1 blok
# ===========================================

# Bangun inverse SBOX44
INV_SBOX44 = [0] * 256
for i, v in enumerate(SBOX44):
    INV_SBOX44[v] = i

# SubBytes versi SBOX44
def sub_bytes_44(state):
    return [SBOX44[b] for b in state]

# Inverse SubBytes versi SBOX44
def inv_sub_bytes_44(state):
    return [INV_SBOX44[b] for b in state]

# Key expansion versi SBOX44
def key_expansion_sbox44(key_bytes: bytes):
    assert len(key_bytes) == 16, "Key harus 16 byte (AES-128)."

    key_schedule = list(key_bytes)
    i = Nk

    while len(key_schedule) < 16 * (Nr + 1):
        temp = key_schedule[-4:]

        if i % Nk == 0:
            temp = temp[1:] + temp[:1]          # RotWord
            temp = [SBOX44[b] for b in temp]    # SubWord dengan SBOX44
            temp[0] ^= Rcon[(i // Nk) - 1]      # Tambah Rcon

        for j in range(4):
            temp[j] ^= key_schedule[-16 + j]

        key_schedule.extend(temp)
        i += 1

    return key_schedule


def aes_encrypt_block_44(block: bytes, key_bytes: bytes) -> bytes:
    assert len(block) == 16
    assert len(key_bytes) == 16

    state = list(block)
    round_keys = key_expansion_sbox44(key_bytes)

    # Initial round
    state = add_round_key(state, round_keys[:16])

    # Ronde 1-9
    for rnd in range(1, Nr):
        state = sub_bytes_44(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, round_keys[16*rnd : 16*(rnd+1)])

    # Final round
    state = sub_bytes_44(state)
    state = shift_rows(state)
    state = add_round_key(state, round_keys[160:176])

    return bytes(state)


def aes_decrypt_block_44(block: bytes, key_bytes: bytes) -> bytes:
    assert len(block) == 16
    assert len(key_bytes) == 16

    state = list(block)
    round_keys = key_expansion_sbox44(key_bytes)

    # Initial decrypt step
    state = add_round_key(state, round_keys[160:176])
    state = inv_shift_rows(state)
    state = inv_sub_bytes_44(state)

    # Rounds 9..1
    for rnd in range(Nr-1, 0, -1):
        state = add_round_key(state, round_keys[16*rnd : 16*(rnd+1)])
        state = inv_mix_columns(state)
        state = inv_shift_rows(state)
        state = inv_sub_bytes_44(state)

    # Final round key
    state = add_round_key(state, round_keys[:16])

    return bytes(state)

# Optional: quick check
key = b"1234567890ABCDEF"
pt = b"ABCDEFGHIJKLMNOP"
ct = aes_encrypt_block_44(pt, key)
print("DecryptOK :", aes_decrypt_block_44(ct, key) == pt)

# ===========================================
# Cell 6 — Wrapper string (AES standar & SBOX44)
# ===========================================

def encrypt_aes_std_str(plaintext: str, key_str: str) -> str:
    """
    Enkripsi plaintext (string bebas panjang) dengan AES standar (ECB, 128-bit).
    Hasil: hex string.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key untuk AES standar harus 16 byte (16 karakter ASCII/UTF-8 sederhana).")

    data = plaintext.encode("utf-8")
    data_padded = pkcs7_pad(data, 16)

    ciphertext = b""
    for i in range(0, len(data_padded), 16):
        block = data_padded[i:i+16]
        ciphertext += aes_encrypt_block_std(block, key_bytes)

    return ciphertext.hex()


def decrypt_aes_std_str(cipher_hex: str, key_str: str) -> str:
    """
    Dekripsi hex string dengan AES standar (ECB, 128-bit).
    Mengembalikan plaintext string.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key untuk AES standar harus 16 byte (16 karakter ASCII/UTF-8 sederhana).")

    ciphertext = bytes.fromhex(cipher_hex)
    if len(ciphertext) % 16 != 0:
        raise ValueError("Panjang ciphertext (dalam byte) harus kelipatan 16.")

    plaintext_padded = b""
    for i in range(0, len(ciphertext), 16):
        block = ciphertext[i:i+16]
        plaintext_padded += aes_decrypt_block_std(block, key_bytes)

    plaintext = pkcs7_unpad(plaintext_padded)
    return plaintext.decode("utf-8")


def encrypt_aes_44_str(plaintext: str, key_str: str) -> str:
    """
    Enkripsi plaintext (string) dengan AES yang memakai SBOX44 (ECB, 128-bit).
    Hasil: hex string.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key untuk AES SBOX44 harus 16 byte (16 karakter).")

    data = plaintext.encode("utf-8")
    data_padded = pkcs7_pad(data, 16)

    ciphertext = b""
    for i in range(0, len(data_padded), 16):
        block = data_padded[i:i+16]
        ciphertext += aes_encrypt_block_44(block, key_bytes)

    return ciphertext.hex()


def decrypt_aes_44_str(cipher_hex: str, key_str: str) -> str:
    """
    Dekripsi hex string dengan AES yang memakai SBOX44 (ECB, 128-bit).
    Mengembalikan plaintext string.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key untuk AES SBOX44 harus 16 byte (16 karakter).")

    ciphertext = bytes.fromhex(cipher_hex)
    if len(ciphertext) % 16 != 0:
        raise ValueError("Panjang ciphertext (dalam byte) harus kelipatan 16.")

    plaintext_padded = b""
    for i in range(0, len(ciphertext), 16):
        block = ciphertext[i:i+16]
        plaintext_padded += aes_decrypt_block_44(block, key_bytes)

    plaintext = pkcs7_unpad(plaintext_padded)
    return plaintext.decode("utf-8")


# ------------------------------------------
# Contoh test cepat (opsional)
# ------------------------------------------
text = "Kriptografi melindungi pesan rahasia"
key  = "1234567890ABCDEF"   # 16 karakter

ct_std = encrypt_aes_std_str(text, key)
ct_44  = encrypt_aes_44_str(text, key)

print("Cipher AES Std :", ct_std)
print("Cipher AES 44  :", ct_44)
print("Dec Std OK :", decrypt_aes_std_str(ct_std, key) == text)
print("Dec 44  OK :", decrypt_aes_44_str(ct_44, key) == text)

# ===========================================
# Cell 7 — Avalanche Effect & Key Sensitivity
# DIPERBAIKI: Gunakan hanya 1 block untuk tes avalanche
# ===========================================

def pkcs7_pad(data: bytes, block_size: int) -> bytes:
    """Padding PKCS7 standar."""
    padding_len = block_size - (len(data) % block_size)
    padding = bytes([padding_len] * padding_len)
    return data + padding


def hex_to_bitstring(h: str) -> str:
    """Konversi hex string → bitstring ('0101...') dengan panjang tepat."""
    if len(h) == 0:
        return ""
    return bin(int(h, 16))[2:].zfill(len(h) * 4)


def bit_diff_stats(hex1: str, hex2: str):
    """
    Hitung:
    - jumlah bit berbeda
    - total bit
    - persentase perubahannya
    """
    b1 = hex_to_bitstring(hex1)
    b2 = hex_to_bitstring(hex2)

    # Samakan panjang kalau sampai beda (jaga-jaga)
    max_len = max(len(b1), len(b2))
    b1 = b1.zfill(max_len)
    b2 = b2.zfill(max_len)

    total = len(b1)
    changed = sum(1 for x, y in zip(b1, b2) if x != y)
    pct = (changed / total) * 100 if total > 0 else 0.0
    return changed, total, pct


def encrypt_bytes_std(data_padded: bytes, key_bytes: bytes) -> bytes:
    """Enkripsi data yang SUDAH dipadding (panjang kelipatan 16) dengan AES standar."""
    assert len(data_padded) % 16 == 0
    out = b""
    for i in range(0, len(data_padded), 16):
        block = data_padded[i:i+16]
        out += aes_encrypt_block_std(block, key_bytes)
    return out


def encrypt_bytes_44(data_padded: bytes, key_bytes: bytes) -> bytes:
    """Enkripsi data yang SUDAH dipadding (panjang kelipatan 16) dengan AES SBOX44."""
    assert len(data_padded) % 16 == 0
    out = b""
    for i in range(0, len(data_padded), 16):
        block = data_padded[i:i+16]
        out += aes_encrypt_block_44(block, key_bytes)
    return out


def avalanche_plaintext(plaintext: str, key_str: str):
    """
    Avalanche Effect terhadap plaintext:
    - Flip 1 bit pada 1 byte pertama dari plaintext.
    - Bandingkan perubahan bit HANYA pada block pertama ciphertext.
    - Ini menghindari bias dari block yang tidak berubah di ECB mode.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key harus 16 byte (16 karakter).")

    pt_bytes = plaintext.encode("utf-8")
    if len(pt_bytes) == 0:
        raise ValueError("Plaintext tidak boleh kosong.")

    # Padding dulu
    pt_padded = pkcs7_pad(pt_bytes, 16)

    # Buat versi dimodifikasi: flip 1 bit di byte pertama
    pt_mod = bytearray(pt_padded)
    pt_mod[0] ^= 0x01  # flip bit LSB
    pt_mod = bytes(pt_mod)

    # Enkripsi dengan AES standar
    ct_std_1_full = encrypt_bytes_std(pt_padded, key_bytes)
    ct_std_2_full = encrypt_bytes_std(pt_mod,    key_bytes)

    # Enkripsi dengan AES SBOX44
    ct_44_1_full = encrypt_bytes_44(pt_padded, key_bytes)
    ct_44_2_full = encrypt_bytes_44(pt_mod,    key_bytes)

    # PERBAIKAN: Ambil HANYA block pertama (16 byte = 128 bit)
    ct_std_1 = ct_std_1_full[:16].hex()
    ct_std_2 = ct_std_2_full[:16].hex()
    ct_44_1 = ct_44_1_full[:16].hex()
    ct_44_2 = ct_44_2_full[:16].hex()

    # Hitung perubahan bit
    changed_std, total_std, pct_std = bit_diff_stats(ct_std_1, ct_std_2)
    changed_44, total_44, pct_44   = bit_diff_stats(ct_44_1,  ct_44_2)

    # Debugging output
    print(f"\n=== DEBUG AVALANCHE PLAINTEXT ===")
    print(f"Plaintext original (hex): {pt_padded.hex()}")
    print(f"Plaintext modified (hex): {pt_mod.hex()}")
    print(f"CT Std 1 (block 1 only): {ct_std_1}")
    print(f"CT Std 2 (block 1 only): {ct_std_2}")
    print(f"CT 44  1 (block 1 only): {ct_44_1}")
    print(f"CT 44  2 (block 1 only): {ct_44_2}")

    return {
        "plaintext": plaintext,
        "key": key_str,
        "std": {
            "ct1": ct_std_1,
            "ct2": ct_std_2,
            "changed_bits": changed_std,
            "total_bits": total_std,
            "percent": pct_std,
        },
        "sbox44": {
            "ct1": ct_44_1,
            "ct2": ct_44_2,
            "changed_bits": changed_44,
            "total_bits": total_44,
            "percent": pct_44,
        }
    }


def key_sensitivity(plaintext: str, key_str: str):
    """
    Key Sensitivity:
    - Flip 1 bit pada key (byte pertama).
    - Bandingkan perubahan bit ciphertext AES standar vs AES SBOX44.
    """
    key_bytes = key_str.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("Key harus 16 byte (16 karakter).")

    pt_bytes = plaintext.encode("utf-8")
    if len(pt_bytes) == 0:
        raise ValueError("Plaintext tidak boleh kosong.")

    pt_padded = pkcs7_pad(pt_bytes, 16)

    # Key asli
    key_orig = key_bytes

    # Key dimodifikasi: flip 1 bit pada byte pertama
    key_mod = bytearray(key_bytes)
    key_mod[0] ^= 0x01
    key_mod = bytes(key_mod)

    # Enkripsi dengan AES standar
    ct_std_1 = encrypt_bytes_std(pt_padded, key_orig).hex()
    ct_std_2 = encrypt_bytes_std(pt_padded, key_mod).hex()

    # Enkripsi dengan AES SBOX44
    ct_44_1 = encrypt_bytes_44(pt_padded, key_orig).hex()
    ct_44_2 = encrypt_bytes_44(pt_padded, key_mod).hex()

    # Hitung perubahan bit
    changed_std, total_std, pct_std = bit_diff_stats(ct_std_1, ct_std_2)
    changed_44, total_44, pct_44   = bit_diff_stats(ct_44_1,  ct_44_2)

    # Debugging output
    print(f"\n=== DEBUG KEY SENSITIVITY ===")
    print(f"Key original (hex): {key_orig.hex()}")
    print(f"Key modified (hex): {key_mod.hex()}")
    print(f"CT Std 1: {ct_std_1}")
    print(f"CT Std 2: {ct_std_2}")
    print(f"CT 44  1: {ct_44_1}")
    print(f"CT 44  2: {ct_44_2}")

    return {
        "plaintext": plaintext,
        "key_original": key_str,
        "key_original_hex": key_orig.hex(),
        "key_modified_hex": key_mod.hex(),
        "std": {
            "ct1": ct_std_1,
            "ct2": ct_std_2,
            "changed_bits": changed_std,
            "total_bits": total_std,
            "percent": pct_std,
        },
        "sbox44": {
            "ct1": ct_44_1,
            "ct2": ct_44_2,
            "changed_bits": changed_44,
            "total_bits": total_44,
            "percent": pct_44,
        }
    }


# ------------------------------------------
# Contoh pakai (opsional)
# ------------------------------------------
text = "Kriptografi melindungi pesan rahasia"
key  = "1234567890ABCDEF"

res_av = avalanche_plaintext(text, key)
print("\n=== HASIL AKHIR ===")
print("Avalanche — AES Std   : {:.2f}% ({} dari {} bit)".format(
    res_av["std"]["percent"], res_av["std"]["changed_bits"], res_av["std"]["total_bits"]
))
print("Avalanche — AES SBOX44: {:.2f}% ({} dari {} bit)".format(
    res_av["sbox44"]["percent"], res_av["sbox44"]["changed_bits"], res_av["sbox44"]["total_bits"]
))

res_key = key_sensitivity(text, key)
print("Key Sensitivity — AES Std   : {:.2f}%".format(res_key["std"]["percent"]))
print("Key Sensitivity — AES SBOX44: {:.2f}%".format(res_key["sbox44"]["percent"]))

# @title
# ===========================================
# Cell 8 — Analisis S-Box per bit (NL & SAC)
# ===========================================

from math import sqrt

# -------------------------------------------
# 1. Konversi S-Box → 8 fungsi Boolean (tiap bit)
# -------------------------------------------

def sbox_bool_coords(sbox):
    """
    Mengubah S-Box ukuran 256 → 8 fungsi Boolean.
    coords[i][x] = bit ke-i dari sbox[x], untuk i=0..7, x=0..255
    """
    coords = []
    for bit in range(8):
        f = []
        for x in range(256):
            f.append((sbox[x] >> bit) & 1)
        coords.append(f)
    return coords  # list 8 elemen, masing-masing list 256 elemen


# -------------------------------------------
# 2. Walsh–Hadamard & Nonlinearity per bit
# -------------------------------------------

def walsh_spectrum(f):
    """
    Walsh spectrum untuk fungsi Boolean f: {0,1}^8 → {0,1}
    f direpresentasikan sebagai list panjang 256, f[x] ∈ {0,1}.
    """
    n = 8
    N = 1 << n  # 256
    W = [0] * N

    for w in range(N):
        s = 0
        for x in range(N):
            # inner product w·x mod 2
            dot = bin(w & x).count("1") & 1
            # (-1)^{f(x) ⊕ (w·x)}
            if (f[x] ^ dot) == 0:
                s += 1
            else:
                s -= 1
        W[w] = s
    return W


def nonlinearity_from_walsh(W):
    """
    Nonlinearity = 2^{n-1} - (1/2) * max_{w} |W_f(w)|, n=8.
    """
    n = 8
    max_w = max(abs(v) for v in W)
    return (1 << (n - 1)) - max_w / 2


def nonlinearity_per_bit(sbox):
    """
    Menghasilkan NL untuk tiap output bit (0..7) dari S-Box.
    Return: list panjang 8.
    """
    coords = sbox_bool_coords(sbox)
    nl_list = []
    for bit in range(8):
        W = walsh_spectrum(coords[bit])
        nl = nonlinearity_from_walsh(W)
        nl_list.append(nl)
    return nl_list


# -------------------------------------------
# 3. SAC (Strict Avalanche Criterion) per output bit
# -------------------------------------------

def sac_matrix(sbox):
    """
    Menghitung SAC matrix 8x8:
    sac[i][j] = Probabilitas bit output i berubah jika input bit j di-flip.
    Ideal: ~0.5
    """
    coords = sbox_bool_coords(sbox)
    sac = [[0.0 for _ in range(8)] for _ in range(8)]

    for out_bit in range(8):
        f = coords[out_bit]
        for in_bit in range(8):
            cnt = 0
            for x in range(256):
                x2 = x ^ (1 << in_bit)
                if f[x] != f[x2]:
                    cnt += 1
            sac[out_bit][in_bit] = cnt / 256.0
    return sac


def sac_stats_per_bit(sac_mat):
    """
    Dari matriks SAC 8x8, ambil:
    - rata-rata per output bit
    - deviasi standar per output bit (seberapa rata 0.5 di semua input bit)
    """
    stats = []
    for out_bit in range(8):
        row = sac_mat[out_bit]
        avg = sum(row) / len(row)
        var = sum((x - avg) ** 2 for x in row) / len(row)
        std = sqrt(var)
        stats.append((avg, std))
    return stats  # list 8 elemen: (avg, std) per output bit


# -------------------------------------------
# 4. Fungsi ringkas untuk analisis dua S-Box
# -------------------------------------------

def analyze_sbox_per_bit(name, sbox):
    """
    Cetak NL & SAC per bit untuk sebuah S-Box.
    name: label string, misal "AES" atau "SBOX44"
    """
    print(f"=== Analisis S-Box: {name} ===")
    nl_list = nonlinearity_per_bit(sbox)
    sac_mat = sac_matrix(sbox)
    sac_stats = sac_stats_per_bit(sac_mat)

    print("Bit |  NL    | SAC avg | SAC std")
    print("--------------------------------------")
    for bit in range(8):
        nl = nl_list[bit]
        sac_avg, sac_std = sac_stats[bit]
        print(f"{bit:3d} | {nl:6.1f} | {sac_avg:7.5f} | {sac_std:7.5f}")
    print()

    # Optional: kembalikan data mentah kalau mau dipakai lagi
    return {
        "nl_per_bit": nl_list,
        "sac_matrix": sac_mat,
        "sac_stats_per_bit": sac_stats,
    }


# -------------------------------------------
# 5. Contoh pemanggilan (opsional)
# -------------------------------------------
data_aes   = analyze_sbox_per_bit("AES S-Box Standar", AES_SBOX)
data_sbox44 = analyze_sbox_per_bit("SBOX44", SBOX44)

# @title
# ===========================================
# Cell 9 — BIC, LAP, DAP (Analisis S-Box lanjutan)
# ===========================================

from math import sqrt

# -------------------------------------------
# Bit Interdependence Criterion — NL
# -------------------------------------------
def bic_nl(sbox):
    coords = sbox_bool_coords(sbox)
    n = len(coords)  # =8

    nl_values = []

    for i in range(n):
        for j in range(i+1, n):
            # Kombinasi XOR dua fungsi Boolean
            f = [coords[i][x] ^ coords[j][x] for x in range(256)]
            W = walsh_spectrum(f)
            nl_values.append(nonlinearity_from_walsh(W))

    return {
        "min": min(nl_values),
        "avg": sum(nl_values) / len(nl_values),
        "all": nl_values
    }


# -------------------------------------------
# Bit Interdependence Criterion — SAC
# -------------------------------------------
def bic_sac(sbox):
    coords = sbox_bool_coords(sbox)
    n = len(coords)
    probs = []

    for i in range(n):
        for j in range(i+1, n):
            for k in range(8):
                cnt = 0
                for x in range(256):
                    x2 = x ^ (1 << k)
                    if (coords[i][x] ^ coords[j][x]) != (coords[i][x2] ^ coords[j][x2]):
                        cnt += 1
                probs.append(cnt / 256.0)

    return {
        "avg": sum(probs) / len(probs),
        "all": probs
    }


# -------------------------------------------
# Linear Approximation Probability (LAP)
# -------------------------------------------
def lap_param(sbox):
    max_S = 0
    for a in range(256):
        for b in range(256):
            if a == 0 and b == 0:
                continue
            S = 0
            for x in range(256):
                fx = sbox[x]
                # parity of dot products
                v = (bin(a & x).count("1") + bin(b & fx).count("1")) & 1
                S += 1 if v == 0 else -1
            max_S = max(max_S, abs(S))

    P = max_S / 256.0
    bias = abs(P - 0.5)

    return {
        "max_P": P,
        "bias": bias
    }


# -------------------------------------------
# Differential Approximation Probability (DAP)
# -------------------------------------------
def dap_param(sbox):
    max_P = 0.0
    for a in range(1, 256):  # a=0 trivial
        for b in range(256):
            cnt = 0
            for x in range(256):
                if (sbox[x] ^ sbox[x ^ a]) == b:
                    cnt += 1
            P = cnt / 256.0
            max_P = max(max_P, P)

    return {
        "max_P": max_P
    }


# -------------------------------------------
# Fungsi wrapper untuk bandingkan dua S-Box
# -------------------------------------------
def analyze_advanced(name, sbox):
    print(f"=== Advanced Analysis: {name} ===")

    bic_nl_res  = bic_nl(sbox)
    bic_sac_res = bic_sac(sbox)
    lap_res     = lap_param(sbox)
    dap_res     = dap_param(sbox)

    print(f"BIC-NL (min) : {bic_nl_res['min']:.1f}")
    print(f"BIC-NL (avg) : {bic_nl_res['avg']:.1f}")
    print(f"BIC-SAC(avg) : {bic_sac_res['avg']:.5f}")
    print(f"LAP bias    : {lap_res['bias']:.6f}")
    print(f"DAP max P   : {dap_res['max_P']:.6f}")
    print()

    return {
        "bic_nl": bic_nl_res,
        "bic_sac": bic_sac_res,
        "lap": lap_res,
        "dap": dap_res,
    }


# -------------------------------------------
# Contoh (opsional)
# -------------------------------------------
res_aes   = analyze_advanced("AES S-Box Standar", AES_SBOX)
res_44    = analyze_advanced("SBOX44", SBOX44)

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile crypto_core.py
# from math import sqrt
#
# # ===========================================
# # S-Box AES & SBOX44
# # ===========================================
#
# AES_SBOX = [
#     99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,
#     202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,
#     183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,
#     4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,
#     9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,
#     83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,
#     208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,
#     81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,
#     205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,
#     96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,
#     224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,
#     231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,
#     186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,
#     112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,
#     225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,
#     140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22,
# ]
#
# SBOX44 = [
#     99,205,85,71,25,127,113,219,63,244,109,159,11,228,94,214,
#     77,177,201,78,5,48,29,30,87,96,193,80,156,200,216,86,
#     116,143,10,14,54,169,148,68,49,75,171,157,92,114,188,194,
#     121,220,131,210,83,135,250,149,253,72,182,33,190,141,249,82,
#     232,50,21,84,215,242,180,198,168,167,103,122,152,162,145,184,
#     43,237,119,183,7,12,125,55,252,206,235,160,140,133,179,192,
#     110,176,221,134,19,6,187,59,26,129,112,73,175,45,24,218,
#     44,66,151,32,137,31,35,147,236,247,117,132,79,136,154,105,
#     199,101,203,52,57,4,153,197,88,76,202,174,233,62,208,91,
#     231,53,1,124,0,28,142,170,158,51,226,65,123,186,239,246,
#     38,56,36,108,8,126,9,189,81,234,212,224,13,3,40,64,
#     172,74,181,118,39,227,130,89,245,166,16,61,106,196,211,107,
#     229,195,138,18,93,207,240,95,58,255,209,217,15,111,46,173,
#     223,42,115,238,139,243,23,98,100,178,37,97,191,213,222,155,
#     165,2,146,204,120,241,163,128,22,90,60,185,67,34,27,248,
#     164,69,41,230,104,47,144,251,20,17,150,225,254,161,102,70,
# ]
#
# # ===========================================
# # AES core utilities
# # ===========================================
#
# Nb = 4
# Nk = 4
# Nr = 10
#
# def xtime(a: int) -> int:
#     """Multiply by x in GF(2^8)"""
#     return ((a << 1) ^ 0x1B) & 0xFF if a & 0x80 else (a << 1) & 0xFF
#
# def gmul(a: int, b: int) -> int:
#     """Galois Field multiplication"""
#     p = 0
#     for _ in range(8):
#         if b & 1:
#             p ^= a
#         hi = a & 0x80
#         a = (a << 1) & 0xFF
#         if hi:
#             a ^= 0x1B
#         b >>= 1
#     return p & 0xFF
#
# def add_round_key(state, round_key):
#     """XOR state with round key"""
#     return [s ^ rk for s, rk in zip(state, round_key)]
#
# def pkcs7_pad(data, block_size=16):
#     """Apply PKCS7 padding"""
#     pad_len = block_size - (len(data) % block_size)
#     return data + bytes([pad_len]) * pad_len
#
# def pkcs7_unpad(data):
#     """Remove PKCS7 padding"""
#     if not data:
#         raise ValueError("Cannot unpad empty data")
#     pad_len = data[-1]
#     if pad_len < 1 or pad_len > 16:
#         raise ValueError("Invalid padding")
#     return data[:-pad_len]
#
# # ===========================================
# # AES Standard Functions
# # ===========================================
#
# INV_AES_SBOX = [0] * 256
# for i, v in enumerate(AES_SBOX):
#     INV_AES_SBOX[v] = i
#
# def sub_bytes_aes(state):
#     """SubBytes using standard AES S-box"""
#     return [AES_SBOX[b] for b in state]
#
# def inv_sub_bytes_aes(state):
#     """Inverse SubBytes using standard AES S-box"""
#     return [INV_AES_SBOX[b] for b in state]
#
# def shift_rows(state):
#     """ShiftRows transformation"""
#     return [
#         state[0],  state[5],  state[10], state[15],
#         state[4],  state[9],  state[14], state[3],
#         state[8],  state[13], state[2],  state[7],
#         state[12], state[1],  state[6],  state[11],
#     ]
#
# def inv_shift_rows(state):
#     """Inverse ShiftRows transformation"""
#     return [
#         state[0],  state[13], state[10], state[7],
#         state[4],  state[1],  state[14], state[11],
#         state[8],  state[5],  state[2],  state[15],
#         state[12], state[9],  state[6],  state[3],
#     ]
#
# def mix_single_column(col):
#     """Mix a single column"""
#     col = col[:]  # Create copy to avoid mutation
#     t = col[0] ^ col[1] ^ col[2] ^ col[3]
#     u = col[0]
#     col[0] ^= t ^ xtime(col[0] ^ col[1])
#     col[1] ^= t ^ xtime(col[1] ^ col[2])
#     col[2] ^= t ^ xtime(col[2] ^ col[3])
#     col[3] ^= t ^ xtime(col[3] ^ u)
#     return col
#
# def mix_columns(state):
#     """MixColumns transformation"""
#     state = state[:]
#     for i in range(0, 16, 4):
#         col = state[i:i+4]
#         state[i:i+4] = mix_single_column(col)
#     return state
#
# def inv_mix_columns(state):
#     """Inverse MixColumns transformation"""
#     state = state[:]
#     for i in range(0, 16, 4):
#         a0, a1, a2, a3 = state[i:i+4]
#         state[i+0] = gmul(a0, 0x0e) ^ gmul(a1, 0x0b) ^ gmul(a2, 0x0d) ^ gmul(a3, 0x09)
#         state[i+1] = gmul(a0, 0x09) ^ gmul(a1, 0x0e) ^ gmul(a2, 0x0b) ^ gmul(a3, 0x0d)
#         state[i+2] = gmul(a0, 0x0d) ^ gmul(a1, 0x09) ^ gmul(a2, 0x0e) ^ gmul(a3, 0x0b)
#         state[i+3] = gmul(a0, 0x0b) ^ gmul(a1, 0x0d) ^ gmul(a2, 0x09) ^ gmul(a3, 0x0e)
#     return state
#
# Rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]
#
# def key_expansion_aes(key_bytes):
#     """AES key expansion using standard S-box"""
#     assert len(key_bytes) == 16
#     key_schedule = list(key_bytes)
#     i = Nk
#     while len(key_schedule) < 16 * (Nr + 1):
#         temp = key_schedule[-4:]
#         if i % Nk == 0:
#             temp = temp[1:] + temp[:1]
#             temp = [AES_SBOX[b] for b in temp]
#             temp[0] ^= Rcon[(i // Nk) - 1]
#         for j in range(4):
#             temp[j] ^= key_schedule[-16 + j]
#         key_schedule.extend(temp)
#         i += 1
#     return key_schedule
#
# def aes_encrypt_block_std(block, key_bytes):
#     """Encrypt single block using standard AES"""
#     assert len(block) == 16
#     state = list(block)
#     round_keys = key_expansion_aes(key_bytes)
#
#     # Initial round
#     state = add_round_key(state, round_keys[:16])
#
#     # Main rounds
#     for r in range(1, Nr):
#         state = sub_bytes_aes(state)
#         state = shift_rows(state)
#         state = mix_columns(state)
#         state = add_round_key(state, round_keys[16*r:16*(r+1)])
#
#     # Final round (no MixColumns)
#     state = sub_bytes_aes(state)
#     state = shift_rows(state)
#     state = add_round_key(state, round_keys[16*Nr:16*(Nr+1)])
#
#     return bytes(state)
#
# def aes_decrypt_block_std(block, key_bytes):
#     """Decrypt single block using standard AES"""
#     assert len(block) == 16
#     state = list(block)
#     round_keys = key_expansion_aes(key_bytes)
#
#     # Initial round
#     state = add_round_key(state, round_keys[16*Nr:16*(Nr+1)])
#     state = inv_shift_rows(state)
#     state = inv_sub_bytes_aes(state)
#
#     # Main rounds
#     for r in range(Nr-1, 0, -1):
#         state = add_round_key(state, round_keys[16*r:16*(r+1)])
#         state = inv_mix_columns(state)
#         state = inv_shift_rows(state)
#         state = inv_sub_bytes_aes(state)
#
#     # Final round
#     state = add_round_key(state, round_keys[:16])
#
#     return bytes(state)
#
# def encrypt_aes_std_str(plaintext, key_str):
#     """Encrypt string using standard AES"""
#     key_bytes = key_str.encode()
#     if len(key_bytes) != 16:
#         raise ValueError("Key AES standar harus 16 byte")
#     data = plaintext.encode()
#     data = pkcs7_pad(data)
#     ct = b""
#     for i in range(0, len(data), 16):
#         ct += aes_encrypt_block_std(data[i:i+16], key_bytes)
#     return ct.hex()
#
# def decrypt_aes_std_str(cipher_hex, key_str):
#     """Decrypt string using standard AES"""
#     key_bytes = key_str.encode()
#     if len(key_bytes) != 16:
#         raise ValueError("Key AES standar harus 16 byte")
#     ct = bytes.fromhex(cipher_hex)
#     pt = b""
#     for i in range(0, len(ct), 16):
#         pt += aes_decrypt_block_std(ct[i:i+16], key_bytes)
#     return pkcs7_unpad(pt).decode()
#
# # ===========================================
# # AES SBOX44 Functions
# # ===========================================
#
# INV_SBOX44 = [0] * 256
# for i, v in enumerate(SBOX44):
#     INV_SBOX44[v] = i
#
# def sub_bytes_44(state):
#     """SubBytes using SBOX44"""
#     return [SBOX44[b] for b in state]
#
# def inv_sub_bytes_44(state):
#     """Inverse SubBytes using SBOX44"""
#     return [INV_SBOX44[b] for b in state]
#
# def key_expansion_sbox44(key_bytes):
#     """Key expansion using SBOX44"""
#     assert len(key_bytes) == 16
#     key_schedule = list(key_bytes)
#     i = Nk
#     while len(key_schedule) < 16 * (Nr + 1):
#         temp = key_schedule[-4:]
#         if i % Nk == 0:
#             temp = temp[1:] + temp[:1]
#             temp = [SBOX44[b] for b in temp]
#             temp[0] ^= Rcon[(i // Nk) - 1]
#         for j in range(4):
#             temp[j] ^= key_schedule[-16 + j]
#         key_schedule.extend(temp)
#         i += 1
#     return key_schedule
#
# def aes_encrypt_block_44(block, key_bytes):
#     """Encrypt single block using SBOX44"""
#     assert len(block) == 16
#     state = list(block)
#     round_keys = key_expansion_sbox44(key_bytes)
#
#     # Initial round
#     state = add_round_key(state, round_keys[:16])
#
#     # Main rounds
#     for r in range(1, Nr):
#         state = sub_bytes_44(state)
#         state = shift_rows(state)
#         state = mix_columns(state)
#         state = add_round_key(state, round_keys[16*r:16*(r+1)])
#
#     # Final round
#     state = sub_bytes_44(state)
#     state = shift_rows(state)
#     state = add_round_key(state, round_keys[16*Nr:16*(Nr+1)])
#
#     return bytes(state)
#
# def aes_decrypt_block_44(block, key_bytes):
#     """Decrypt single block using SBOX44"""
#     assert len(block) == 16
#     state = list(block)
#     round_keys = key_expansion_sbox44(key_bytes)
#
#     # Initial round
#     state = add_round_key(state, round_keys[16*Nr:16*(Nr+1)])
#     state = inv_shift_rows(state)
#     state = inv_sub_bytes_44(state)
#
#     # Main rounds
#     for r in range(Nr-1, 0, -1):
#         state = add_round_key(state, round_keys[16*r:16*(r+1)])
#         state = inv_mix_columns(state)
#         state = inv_shift_rows(state)
#         state = inv_sub_bytes_44(state)
#
#     # Final round
#     state = add_round_key(state, round_keys[:16])
#
#     return bytes(state)
#
# def encrypt_aes_44_str(plaintext, key_str):
#     """Encrypt string using SBOX44"""
#     key_bytes = key_str.encode()
#     if len(key_bytes) != 16:
#         raise ValueError("Key AES SBOX44 harus 16 byte")
#     data = plaintext.encode()
#     data = pkcs7_pad(data)
#     ct = b""
#     for i in range(0, len(data), 16):
#         ct += aes_encrypt_block_44(data[i:i+16], key_bytes)
#     return ct.hex()
#
# def decrypt_aes_44_str(cipher_hex, key_str):
#     """Decrypt string using SBOX44"""
#     key_bytes = key_str.encode()
#     if len(key_bytes) != 16:
#         raise ValueError("Key AES SBOX44 harus 16 byte")
#     ct = bytes.fromhex(cipher_hex)
#     pt = b""
#     for i in range(0, len(ct), 16):
#         pt += aes_decrypt_block_44(ct[i:i+16], key_bytes)
#     return pkcs7_unpad(pt).decode()
#
# # ===========================================
# # Bit Difference Calculation
# # ===========================================
#
# def bit_diff_stats(hex1, hex2):
#     """Calculate bit difference statistics between two hex strings"""
#     b1 = bytes.fromhex(hex1)
#     b2 = bytes.fromhex(hex2)
#     if len(b1) != len(b2):
#         raise ValueError("Hex strings must have same length")
#
#     total_bits = len(b1) * 8
#     changed = 0
#     for x, y in zip(b1, b2):
#         changed += bin(x ^ y).count("1")
#
#     pct = (changed / total_bits) * 100
#     # Return dictionary format untuk kemudahan akses
#     return {
#         "changed_bits": changed,
#         "total_bits": total_bits,
#         "percent": round(pct, 2)
#     }
#
# # ===========================================
# # Avalanche Effect Test
# # ===========================================
#
# def avalanche_plaintext(plaintext, key_str):
#     """Test avalanche effect by flipping one bit in plaintext"""
#     key = key_str.encode()
#     if len(key) != 16:
#         raise ValueError("Key harus 16 byte")
#
#     # Prepare original block
#     block = plaintext.encode()[:16].ljust(16, b"\x00")
#
#     # Create modified block (flip first bit)
#     block_mod = bytearray(block)
#     block_mod[0] ^= 0x01
#     block_mod = bytes(block_mod)
#
#     # Encrypt with standard AES
#     ct1_std = aes_encrypt_block_std(block, key).hex()
#     ct2_std = aes_encrypt_block_std(block_mod, key).hex()
#
#     # Encrypt with SBOX44
#     ct1_44 = aes_encrypt_block_44(block, key).hex()
#     ct2_44 = aes_encrypt_block_44(block_mod, key).hex()
#
#     return {
#         "std": bit_diff_stats(ct1_std, ct2_std),
#         "sbox44": bit_diff_stats(ct1_44, ct2_44),
#         "plaintext_original": block.hex(),
#         "plaintext_modified": block_mod.hex()
#     }
#
# # ===========================================
# # Key Sensitivity Test
# # ===========================================
#
# def key_sensitivity(plaintext, key_str):
#     """Test sensitivity to key changes"""
#     pt = plaintext.encode()[:16].ljust(16, b"\x00")
#     key = key_str.encode()
#     if len(key) != 16:
#         raise ValueError("Key harus 16 byte")
#
#     # Create modified key (flip first bit)
#     key_mod = bytearray(key)
#     key_mod[0] ^= 0x01
#     key_mod = bytes(key_mod)
#
#     # Encrypt with standard AES
#     ct1_std = aes_encrypt_block_std(pt, key).hex()
#     ct2_std = aes_encrypt_block_std(pt, key_mod).hex()
#
#     # Encrypt with SBOX44
#     ct1_44 = aes_encrypt_block_44(pt, key).hex()
#     ct2_44 = aes_encrypt_block_44(pt, key_mod).hex()
#
#     return {
#         "std": bit_diff_stats(ct1_std, ct2_std),
#         "sbox44": bit_diff_stats(ct1_44, ct2_44),
#         "key_original_hex": key.hex(),
#         "key_modified_hex": key_mod.hex()
#     }

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile avalanche_tester.py
# """
# Bulk Avalanche Effect & Key Sensitivity Testing
# Untuk mendapatkan hasil statistik yang lebih akurat
# """
#
# import random
# import string
# from typing import Dict, List
# import crypto_core as cc
#
#
# def generate_random_text(length: int = 16) -> str:
#     """Generate random plaintext dengan panjang tertentu"""
#     chars = string.ascii_letters + string.digits + string.punctuation + " "
#     return ''.join(random.choice(chars) for _ in range(length))
#
#
# def generate_random_key() -> str:
#     """Generate random 16-character key"""
#     chars = string.ascii_letters + string.digits
#     return ''.join(random.choice(chars) for _ in range(16))
#
#
# def run_bulk_avalanche_test(n_samples: int = 100, progress_callback=None) -> Dict:
#     """
#     Jalankan avalanche test pada n_samples kombinasi plaintext-key berbeda
#     PERBAIKAN: Gunakan plaintext 16 byte penuh untuk konsistensi
#     """
#     results_std = []
#     results_sbox44 = []
#     errors = []
#
#     for i in range(n_samples):
#         # Generate random plaintext TEPAT 16 byte (1 block AES)
#         plaintext = generate_random_text(16)  # PERBAIKAN: Fixed length 16
#         key = generate_random_key()
#
#         try:
#             # Test avalanche effect
#             result = cc.avalanche_plaintext(plaintext, key)
#
#             results_std.append(result["std"]["percent"])
#             results_sbox44.append(result["sbox44"]["percent"])
#
#             # Update progress jika ada callback
#             if progress_callback:
#                 progress_callback((i + 1) / n_samples)
#
#         except Exception as e:
#             errors.append(f"Sample {i+1}: {str(e)}")
#             # Tetap update progress meskipun error
#             if progress_callback:
#                 progress_callback((i + 1) / n_samples)
#             continue
#
#     # Debug: print errors jika ada
#     if errors:
#         print(f"\n=== ERRORS FOUND ({len(errors)}) ===")
#         for err in errors[:5]:  # Print 5 error pertama
#             print(err)
#
#     # Hitung statistik
#     if not results_std or not results_sbox44:
#         print(f"GAGAL! results_std={len(results_std)}, results_sbox44={len(results_sbox44)}")
#         return None
#
#     avg_std = sum(results_std) / len(results_std)
#     avg_sbox44 = sum(results_sbox44) / len(results_sbox44)
#
#     print(f"\n=== SUCCESS ===")
#     print(f"Samples tested: {len(results_std)}/{n_samples}")
#     print(f"AES Std mean: {avg_std:.2f}%")
#     print(f"SBOX44 mean: {avg_sbox44:.2f}%")
#
#     return {
#         "n_samples": len(results_std),
#         "std": {
#             "mean": avg_std,
#             "min": min(results_std),
#             "max": max(results_std),
#             "all_values": results_std
#         },
#         "sbox44": {
#             "mean": avg_sbox44,
#             "min": min(results_sbox44),
#             "max": max(results_sbox44),
#             "all_values": results_sbox44
#         }
#     }
#
#
# def run_bulk_key_sensitivity_test(n_samples: int = 100, progress_callback=None) -> Dict:
#     """
#     Jalankan key sensitivity test pada n_samples kombinasi plaintext-key berbeda
#     PERBAIKAN: Gunakan plaintext 16 byte penuh untuk konsistensi
#     """
#     results_std = []
#     results_sbox44 = []
#     errors = []
#
#     for i in range(n_samples):
#         # Generate random plaintext TEPAT 16 byte (1 block AES)
#         plaintext = generate_random_text(16)  # PERBAIKAN: Fixed length 16
#         key = generate_random_key()
#
#         try:
#             # Test key sensitivity
#             result = cc.key_sensitivity(plaintext, key)
#
#             results_std.append(result["std"]["percent"])
#             results_sbox44.append(result["sbox44"]["percent"])
#
#             # Update progress jika ada callback
#             if progress_callback:
#                 progress_callback((i + 1) / n_samples)
#
#         except Exception as e:
#             errors.append(f"Sample {i+1}: {str(e)}")
#             # Tetap update progress meskipun error
#             if progress_callback:
#                 progress_callback((i + 1) / n_samples)
#             continue
#
#     # Debug: print errors jika ada
#     if errors:
#         print(f"\n=== ERRORS FOUND ({len(errors)}) ===")
#         for err in errors[:5]:  # Print 5 error pertama
#             print(err)
#
#     # Hitung statistik
#     if not results_std or not results_sbox44:
#         print(f"GAGAL! results_std={len(results_std)}, results_sbox44={len(results_sbox44)}")
#         return None
#
#     avg_std = sum(results_std) / len(results_std)
#     avg_sbox44 = sum(results_sbox44) / len(results_sbox44)
#
#     print(f"\n=== SUCCESS ===")
#     print(f"Samples tested: {len(results_std)}/{n_samples}")
#     print(f"AES Std mean: {avg_std:.2f}%")
#     print(f"SBOX44 mean: {avg_sbox44:.2f}%")
#
#     return {
#         "n_samples": len(results_std),
#         "std": {
#             "mean": avg_std,
#             "min": min(results_std),
#             "max": max(results_std),
#             "all_values": results_std
#         },
#         "sbox44": {
#             "mean": avg_sbox44,
#             "min": min(results_sbox44),
#             "max": max(results_sbox44),
#             "all_values": results_sbox44
#         }
#     }
#
#
# def calculate_sac_deviation(percentages: List[float]) -> float:
#     """
#     Hitung rata-rata deviasi dari ideal SAC (50%)
#     Semakin kecil = semakin baik
#     """
#     deviations = [abs(p - 50.0) for p in percentages]
#     return sum(deviations) / len(deviations)
#
#
# def get_quality_rating(mean_percent: float) -> str:
#     """Rating kualitas berdasarkan kedekatan dengan 50%"""
#     deviation = abs(mean_percent - 50.0)
#
#     if deviation < 0.5:
#         return "Excellent ⭐⭐⭐⭐⭐"
#     elif deviation < 1.0:
#         return "Very Good ⭐⭐⭐⭐"
#     elif deviation < 2.0:
#         return "Good ⭐⭐⭐"
#     elif deviation < 5.0:
#         return "Fair ⭐⭐"
#     else:
#         return "Poor ⭐"

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile sac_tester.py
# """
# SAC (Strict Avalanche Criterion) Test
# Sesuai dengan paper Pak Alam - Equation 6
# """
#
# import crypto_core as cc
# import numpy as np
#
#
# def calculate_sac_for_sbox(sbox_encrypt_func, key_bytes):
#     """
#     Hitung SAC untuk S-box (sesuai paper)
#
#     Paper Formula (Eq. 6):
#     S(x,i) = (1/2^n) × Σ [f(x) ⊕ f(x ⊕ c_n^i)]
#
#     Args:
#         sbox_encrypt_func: Fungsi enkripsi (aes_encrypt_block_std atau aes_encrypt_block_44)
#         key_bytes: Key 16 byte
#
#     Returns:
#         SAC matrix 8x8 dan SAC value (average)
#     """
#     n = 8  # 8 bit input
#     sac_matrix = np.zeros((n, n))
#
#     # Test untuk semua kemungkinan input (2^8 = 256)
#     for x in range(256):
#         # Convert ke bytes (1 block = 16 bytes, tapi kita test byte pertama)
#         plaintext = bytes([x]) + b'\x00' * 15
#
#         # Enkripsi plaintext asli
#         ct_original = sbox_encrypt_func(plaintext, key_bytes)
#
#         # Test flip tiap bit (i = 0 sampai 7)
#         for i in range(n):
#             # Flip bit ke-i
#             x_flipped = x ^ (1 << i)
#             plaintext_flipped = bytes([x_flipped]) + b'\x00' * 15
#
#             # Enkripsi plaintext yang sudah di-flip
#             ct_flipped = sbox_encrypt_func(plaintext_flipped, key_bytes)
#
#             # XOR kedua ciphertext
#             xor_result = bytes(a ^ b for a, b in zip(ct_original, ct_flipped))
#
#             # Hitung berapa bit yang berubah untuk tiap output bit (j = 0 sampai 7)
#             # Kita fokus di byte pertama output (8 bit pertama)
#             for j in range(n):
#                 # Cek apakah bit ke-j berubah
#                 if (xor_result[0] >> j) & 1:
#                     sac_matrix[i][j] += 1
#
#     # Normalize: bagi dengan 2^n (256) untuk dapat probabilitas
#     sac_matrix = sac_matrix / 256.0
#
#     # SAC value adalah rata-rata dari seluruh matrix
#     sac_value = np.mean(sac_matrix)
#
#     return sac_matrix, sac_value
#
#
# def test_sac_comparison(key_str="1234567890ABCDEF"):
#     """
#     Bandingkan SAC antara AES Standard dan SBOX44
#
#     Args:
#         key_str: Key 16 karakter (default: "1234567890ABCDEF")
#
#     Returns:
#         Dictionary hasil SAC untuk kedua algoritma
#     """
#     key_bytes = key_str.encode('utf-8')
#
#     print("=" * 60)
#     print("SAC (Strict Avalanche Criterion) Test")
#     print("=" * 60)
#     print(f"Testing dengan key: {key_str}")
#     print(f"Testing 256 kombinasi input × 8 bit flips = 2048 tests")
#     print()
#
#     # Test AES Standard
#     print("Testing AES Standard...")
#     sac_matrix_std, sac_value_std = calculate_sac_for_sbox(
#         cc.aes_encrypt_block_std,
#         key_bytes
#     )
#
#     # Test SBOX44
#     print("Testing SBOX44...")
#     sac_matrix_44, sac_value_44 = calculate_sac_for_sbox(
#         cc.aes_encrypt_block_44,
#         key_bytes
#     )
#
#     print()
#     print("=" * 60)
#     print("HASIL SAC TEST")
#     print("=" * 60)
#     print(f"AES Standard SAC: {sac_value_std:.5f}")
#     print(f"SBOX44 SAC:       {sac_value_44:.5f}")
#     print()
#     print(f"Deviasi dari ideal (0.5):")
#     print(f"  AES Standard: {abs(sac_value_std - 0.5):.5f}")
#     print(f"  SBOX44:       {abs(sac_value_44 - 0.5):.5f}")
#     print()
#
#     # Tentukan pemenang
#     if abs(sac_value_44 - 0.5) < abs(sac_value_std - 0.5):
#         print("🏆 WINNER: SBOX44 (lebih dekat ke ideal 0.5)")
#         improvement = ((abs(sac_value_std - 0.5) - abs(sac_value_44 - 0.5)) / abs(sac_value_44 - 0.5)) * 100
#         print(f"   Improvement: {improvement:.3f}%")
#     else:
#         print("🏆 WINNER: AES Standard (lebih dekat ke ideal 0.5)")
#         improvement = ((abs(sac_value_44 - 0.5) - abs(sac_value_std - 0.5)) / abs(sac_value_std - 0.5)) * 100
#         print(f"   Improvement: {improvement:.3f}%")
#
#     print()
#     print("SAC Matrix 8x8 untuk AES Standard:")
#     print(sac_matrix_std)
#     print()
#     print("SAC Matrix 8x8 untuk SBOX44:")
#     print(sac_matrix_44)
#     print("=" * 60)
#
#     return {
#         "std": {
#             "sac_value": sac_value_std,
#             "sac_matrix": sac_matrix_std.tolist(),
#             "deviation": abs(sac_value_std - 0.5)
#         },
#         "sbox44": {
#             "sac_value": sac_value_44,
#             "sac_matrix": sac_matrix_44.tolist(),
#             "deviation": abs(sac_value_44 - 0.5)
#         }
#     }
#
#
# def bulk_sac_test(n_keys=100):
#     """
#     Test SAC dengan banyak key berbeda untuk hasil statistik
#
#     Args:
#         n_keys: Jumlah random key yang akan ditest
#
#     Returns:
#         Dictionary dengan statistik hasil
#     """
#     import random
#     import string
#
#     sac_values_std = []
#     sac_values_44 = []
#
#     print("=" * 60)
#     print(f"BULK SAC TEST dengan {n_keys} random keys")
#     print("=" * 60)
#
#     for i in range(n_keys):
#         # Generate random key
#         key_str = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(16))
#         key_bytes = key_str.encode('utf-8')
#
#         # Test SAC untuk kedua algoritma
#         _, sac_std = calculate_sac_for_sbox(cc.aes_encrypt_block_std, key_bytes)
#         _, sac_44 = calculate_sac_for_sbox(cc.aes_encrypt_block_44, key_bytes)
#
#         sac_values_std.append(sac_std)
#         sac_values_44.append(sac_44)
#
#         if (i + 1) % 10 == 0:
#             print(f"Progress: {i+1}/{n_keys} keys tested...")
#
#     # Hitung statistik
#     avg_std = sum(sac_values_std) / len(sac_values_std)
#     avg_44 = sum(sac_values_44) / len(sac_values_44)
#
#     print()
#     print("=" * 60)
#     print("BULK SAC TEST RESULTS")
#     print("=" * 60)
#     print(f"AES Standard - Mean SAC: {avg_std:.5f}")
#     print(f"SBOX44 - Mean SAC:       {avg_44:.5f}")
#     print()
#     print(f"Deviasi dari ideal (0.5):")
#     print(f"  AES Standard: {abs(avg_std - 0.5):.5f}")
#     print(f"  SBOX44:       {abs(avg_44 - 0.5):.5f}")
#     print()
#
#     # Tentukan pemenang
#     if abs(avg_44 - 0.5) < abs(avg_std - 0.5):
#         print("🏆 WINNER: SBOX44 (lebih dekat ke ideal 0.5)")
#         improvement = ((abs(avg_std - 0.5) - abs(avg_44 - 0.5)) / abs(avg_44 - 0.5)) * 100
#         print(f"   Improvement: {improvement:.3f}%")
#     else:
#         print("🏆 WINNER: AES Standard (lebih dekat ke ideal 0.5)")
#         improvement = ((abs(avg_44 - 0.5) - abs(avg_std - 0.5)) / abs(avg_std - 0.5)) * 100
#         print(f"   Improvement: {improvement:.3f}%")
#
#     print("=" * 60)
#
#     return {
#         "n_keys": n_keys,
#         "std": {
#             "mean": avg_std,
#             "min": min(sac_values_std),
#             "max": max(sac_values_std),
#             "all_values": sac_values_std,
#             "deviation": abs(avg_std - 0.5)
#         },
#         "sbox44": {
#             "mean": avg_44,
#             "min": min(sac_values_44),
#             "max": max(sac_values_44),
#             "all_values": sac_values_44,
#             "deviation": abs(avg_44 - 0.5)
#         }
#     }
#
#
# # Contoh penggunaan
# if __name__ == "__main__":
#     # Test dengan 1 key
#     print("\n### SINGLE KEY TEST ###\n")
#     test_sac_comparison()
#
#     # Test dengan banyak key (bulk)
#     print("\n\n### BULK TEST ###\n")
#     bulk_sac_test(n_keys=50)

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile app.py
#
# import streamlit as st
# import pandas as pd
# import crypto_core as cc
# import avalanche_tester as at
# import sac_tester as sac
# import plotly.graph_objects as go
# from plotly.subplots import make_subplots
# import numpy as np
#
# # =====================================
# # Streamlit Config
# # =====================================
# st.set_page_config(
#     page_title="AES vs SBOX44 Analyzer",
#     page_icon="🔐",
#     layout="wide",
# )
#
# # ---------- Sidebar Navigation ----------
# st.sidebar.title("📌 Navigasi Menu")
# menu = st.sidebar.radio(
#     "Pilih Menu:",
#     ["Beranda", "Enkripsi & Dekripsi", "Avalanche Effect", "Key Sensitivity", "SAC Test (Paper)", "Bulk Test Analysis"]
# )
#
# # ---------- Session State ----------
# if "plain" not in st.session_state:
#     st.session_state["plain"] = ""
# if "key" not in st.session_state:
#     st.session_state["key"] = ""
#
#
# # ==============================================================
# # BERANDA
# # ==============================================================
# if menu == "Beranda":
#     st.title("🔐 AES vs SBOX44 Cryptographic Analyzer")
#     st.markdown("### Aplikasi Perbandingan Algoritma AES Standard dan AES SBOX44")
#
#     st.markdown("---")
#
#     col1, col2, col3 = st.columns(3)
#
#     with col1:
#         st.metric(
#             label="AES Standard",
#             value="10 Rounds",
#             delta="128-bit"
#         )
#
#     with col2:
#         st.metric(
#             label="AES SBOX44",
#             value="Modified S-Box",
#             delta="Custom"
#         )
#
#     with col3:
#         st.metric(
#             label="Total Fitur",
#             value="5 Analisis",
#             delta="Lengkap"
#         )
#
#     st.markdown("---")
#
#     st.subheader("📋 Fitur Aplikasi")
#
#     col_a, col_b = st.columns(2)
#
#     with col_a:
#         st.markdown("""
#         **🔒 Enkripsi & Dekripsi**
#         - Enkripsi plaintext menjadi ciphertext
#         - Dekripsi ciphertext kembali ke plaintext
#         - Support AES Standard dan SBOX44
#         """)
#
#         st.markdown("""
#         **⚡ Avalanche Effect**
#         - Test perubahan 1 bit pada plaintext
#         - Mengukur persentase perubahan ciphertext
#         - Ideal: ~50% bit berubah
#         """)
#
#     with col_b:
#         st.markdown("""
#         **🔑 Key Sensitivity**
#         - Test perubahan 1 bit pada key
#         - Mengukur dampak ke ciphertext
#         - Validasi kekuatan key expansion
#         """)
#
#         st.markdown("""
#         **🎯 SAC Test (Paper)** ⭐ NEW!
#         - Strict Avalanche Criterion sesuai paper
#         - Test 256 input × 8 bit flips
#         - SAC Matrix 8×8 visualization
#         """)
#
#         st.markdown("""
#         **📊 Bulk Test Analysis**
#         - Test dengan ratusan sampel random
#         - Statistik comprehensive
#         - Visualisasi distribusi hasil
#         """)
#
#     st.markdown("---")
#     st.info("💡 Pilih menu di sidebar untuk memulai analisis")
#
#
#
# # ==============================================================
# # ENKRIPSI & DEKRIPSI
# # ==============================================================
# elif menu == "Enkripsi & Dekripsi":
#     st.title("🔒 Enkripsi & Dekripsi")
#
#     st.markdown("---")
#
#     # Tab untuk Enkripsi dan Dekripsi
#     tab1, tab2 = st.tabs(["🔐 Enkripsi", "🔓 Dekripsi"])
#
#     # ========== TAB ENKRIPSI ==========
#     with tab1:
#         st.subheader("Enkripsi Plaintext")
#
#         col_input, col_output = st.columns([1, 1])
#
#         with col_input:
#             st.markdown("**Input Data**")
#             plaintext = st.text_area(
#                 "Plaintext:",
#                 value=st.session_state["plain"],
#                 height=150,
#                 placeholder="Masukkan teks yang ingin dienkripsi..."
#             )
#
#             key = st.text_input(
#                 "Key (16 karakter):",
#                 value=st.session_state["key"],
#                 max_chars=16,
#                 placeholder="Contoh: MySecretKey12345"
#             )
#
#             algo = st.radio(
#                 "Pilih Algoritma:",
#                 ["AES Standard", "AES SBOX44"],
#                 horizontal=True
#             )
#
#             st.session_state["plain"] = plaintext
#             st.session_state["key"] = key
#
#             encrypt_btn = st.button("🚀 Enkripsi", use_container_width=True)
#
#         with col_output:
#             st.markdown("**Output Hasil**")
#
#             if encrypt_btn:
#                 if not plaintext:
#                     st.error("❌ Plaintext tidak boleh kosong!")
#                 elif len(key) != 16:
#                     st.error("❌ Key harus tepat 16 karakter!")
#                 else:
#                     try:
#                         with st.spinner("Mengenkripsi..."):
#                             if algo == "AES Standard":
#                                 cipher = cc.encrypt_aes_std_str(plaintext, key)
#                             else:
#                                 cipher = cc.encrypt_aes_44_str(plaintext, key)
#
#                         st.success("✅ Enkripsi berhasil!")
#                         st.text_area(
#                             "Ciphertext (HEX):",
#                             value=cipher,
#                             height=150
#                         )
#
#                         st.info(f"📊 Panjang: {len(cipher)} karakter hex ({len(cipher)//2} bytes)")
#
#                     except Exception as e:
#                         st.error(f"❌ Error: {str(e)}")
#
#     # ========== TAB DEKRIPSI ==========
#     with tab2:
#         st.subheader("Dekripsi Ciphertext")
#
#         col_input2, col_output2 = st.columns([1, 1])
#
#         with col_input2:
#             st.markdown("**Input Data**")
#             cipher_hex = st.text_area(
#                 "Ciphertext (HEX):",
#                 height=150,
#                 placeholder="Paste ciphertext dalam format hexadecimal..."
#             )
#
#             key_decrypt = st.text_input(
#                 "Key (16 karakter):",
#                 value=st.session_state["key"],
#                 max_chars=16,
#                 placeholder="Gunakan key yang sama saat enkripsi",
#                 key="key_decrypt"
#             )
#
#             algo_decrypt = st.radio(
#                 "Pilih Algoritma:",
#                 ["AES Standard", "AES SBOX44"],
#                 horizontal=True,
#                 key="algo_decrypt"
#             )
#
#             decrypt_btn = st.button("🔓 Dekripsi", use_container_width=True)
#
#         with col_output2:
#             st.markdown("**Output Hasil**")
#
#             if decrypt_btn:
#                 if not cipher_hex:
#                     st.error("❌ Ciphertext tidak boleh kosong!")
#                 elif len(key_decrypt) != 16:
#                     st.error("❌ Key harus tepat 16 karakter!")
#                 else:
#                     try:
#                         with st.spinner("Mendekripsi..."):
#                             if algo_decrypt == "AES Standard":
#                                 plaintext_result = cc.decrypt_aes_std_str(cipher_hex, key_decrypt)
#                             else:
#                                 plaintext_result = cc.decrypt_aes_44_str(cipher_hex, key_decrypt)
#
#                         st.success("✅ Dekripsi berhasil!")
#                         st.text_area(
#                             "Plaintext:",
#                             value=plaintext_result,
#                             height=150
#                         )
#
#                     except Exception as e:
#                         st.error(f"❌ Error dekripsi: {str(e)}")
#                         st.warning("💡 Pastikan key dan algoritma sama dengan saat enkripsi!")
#
#
#
# # ==============================================================
# # AVALANCHE EFFECT
# # ==============================================================
# elif menu == "Avalanche Effect":
#     st.title("⚡ Avalanche Effect")
#
#     st.markdown("""
#     **Avalanche Effect** mengukur seberapa besar perubahan output ketika input diubah sedikit (1 bit).
#
#     Pada algoritma enkripsi yang baik, perubahan 1 bit pada plaintext harus mengubah sekitar **50%** bit pada ciphertext.
#     """)
#
#     st.markdown("---")
#
#     col_left, col_right = st.columns([2, 3])
#
#     with col_left:
#         st.subheader("Input Parameter")
#
#         plaintext_av = st.text_input(
#             "Plaintext:",
#             value=st.session_state["plain"],
#             placeholder="Contoh: Hello World"
#         )
#
#         key_av = st.text_input(
#             "Key (16 karakter):",
#             value=st.session_state["key"],
#             max_chars=16,
#             placeholder="Contoh: MySecretKey12345"
#         )
#
#         st.info("ℹ️ Sistem akan mengubah 1 bit pertama pada plaintext dan membandingkan hasilnya")
#
#         calc_btn = st.button("🔥 Hitung Avalanche Effect", use_container_width=True)
#
#     with col_right:
#         st.subheader("Hasil Analisis")
#
#         if calc_btn:
#             if not plaintext_av:
#                 st.error("❌ Plaintext tidak boleh kosong!")
#             elif len(key_av) != 16:
#                 st.error("❌ Key harus tepat 16 karakter!")
#             else:
#                 try:
#                     with st.spinner("Menghitung avalanche effect..."):
#                         result = cc.avalanche_plaintext(plaintext_av, key_av)
#
#                     # Tabel hasil
#                     df = pd.DataFrame({
#                         "Algoritma": ["AES Standard", "AES SBOX44"],
#                         "Changed Bits": [
#                             result["std"]["changed_bits"],
#                             result["sbox44"]["changed_bits"]
#                         ],
#                         "Total Bits": [
#                             result["std"]["total_bits"],
#                             result["sbox44"]["total_bits"]
#                         ],
#                         "Percentage (%)": [
#                             result["std"]["percent"],
#                             result["sbox44"]["percent"]
#                         ]
#                     })
#
#                     st.dataframe(df, use_container_width=True)
#
#                     # Interpretasi
#                     avg_pct = (result["std"]["percent"] + result["sbox44"]["percent"]) / 2
#
#                     st.markdown("### 📊 Interpretasi Hasil")
#
#                     if 45 <= avg_pct <= 55:
#                         st.success(f"✅ **Avalanche effect sangat baik!** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Perubahan mendekati ideal 50%, menunjukkan difusi yang sangat baik.")
#                     elif 40 <= avg_pct <= 60:
#                         st.info(f"ℹ️ **Avalanche effect baik** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Perubahan masih dalam range acceptable.")
#                     else:
#                         st.warning(f"⚠️ **Avalanche effect perlu perbaikan** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Perubahan di luar range ideal.")
#
#                     # Detail
#                     with st.expander("📋 Detail Teknis"):
#                         st.markdown(f"""
#                         **Plaintext Original:** `{result['plaintext_original']}`
#
#                         **Plaintext Modified:** `{result['plaintext_modified']}`
#
#                         **Perubahan:** 1 bit pada byte pertama
#
#                         **Standar Ideal:** 45-55% bit berubah
#                         """)
#
#                 except Exception as e:
#                     st.error(f"❌ Error: {str(e)}")
#
#
#
# # ==============================================================
# # KEY SENSITIVITY
# # ==============================================================
# elif menu == "Key Sensitivity":
#     st.title("🔑 Key Sensitivity")
#
#     st.markdown("""
#     **Key Sensitivity** mengukur seberapa sensitif algoritma terhadap perubahan key.
#
#     Perubahan 1 bit pada key seharusnya mengubah sekitar **50%** bit pada ciphertext,
#     menunjukkan bahwa key expansion berfungsi dengan baik.
#     """)
#
#     st.markdown("---")
#
#     col_left, col_right = st.columns([2, 3])
#
#     with col_left:
#         st.subheader("Input Parameter")
#
#         plaintext_ks = st.text_input(
#             "Plaintext:",
#             value=st.session_state["plain"],
#             placeholder="Contoh: Hello World"
#         )
#
#         key_ks = st.text_input(
#             "Key (16 karakter):",
#             value=st.session_state["key"],
#             max_chars=16,
#             placeholder="Contoh: MySecretKey12345"
#         )
#
#         st.info("ℹ️ Sistem akan mengubah 1 bit pertama pada key dan membandingkan hasilnya")
#
#         calc_ks_btn = st.button("🔍 Hitung Key Sensitivity", use_container_width=True)
#
#     with col_right:
#         st.subheader("Hasil Analisis")
#
#         if calc_ks_btn:
#             if not plaintext_ks:
#                 st.error("❌ Plaintext tidak boleh kosong!")
#             elif len(key_ks) != 16:
#                 st.error("❌ Key harus tepat 16 karakter!")
#             else:
#                 try:
#                     with st.spinner("Menghitung key sensitivity..."):
#                         result = cc.key_sensitivity(plaintext_ks, key_ks)
#
#                     # Tabel hasil
#                     df = pd.DataFrame({
#                         "Algoritma": ["AES Standard", "AES SBOX44"],
#                         "Changed Bits": [
#                             result["std"]["changed_bits"],
#                             result["sbox44"]["changed_bits"]
#                         ],
#                         "Total Bits": [
#                             result["std"]["total_bits"],
#                             result["sbox44"]["total_bits"]
#                         ],
#                         "Percentage (%)": [
#                             result["std"]["percent"],
#                             result["sbox44"]["percent"]
#                         ]
#                     })
#
#                     st.dataframe(df, use_container_width=True)
#
#                     # Interpretasi
#                     avg_pct = (result["std"]["percent"] + result["sbox44"]["percent"]) / 2
#
#                     st.markdown("### 📊 Interpretasi Hasil")
#
#                     if 45 <= avg_pct <= 55:
#                         st.success(f"✅ **Key sensitivity sangat baik!** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Key expansion bekerja optimal, perubahan key menyebar dengan baik.")
#                     elif 40 <= avg_pct <= 60:
#                         st.info(f"ℹ️ **Key sensitivity baik** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Key expansion masih dalam range acceptable.")
#                     else:
#                         st.warning(f"⚠️ **Key sensitivity perlu perbaikan** (Rata-rata: {avg_pct:.2f}%)")
#                         st.markdown("Perubahan key kurang optimal.")
#
#                     # Detail
#                     with st.expander("📋 Detail Teknis"):
#                         st.markdown(f"""
#                         **Key Original (HEX):** `{result['key_original_hex']}`
#
#                         **Key Modified (HEX):** `{result['key_modified_hex']}`
#
#                         **Perubahan:** 1 bit pada byte pertama
#
#                         **Standar Ideal:** 45-55% bit berubah
#                         """)
#
#                 except Exception as e:
#                     st.error(f"❌ Error: {str(e)}")
#
#
# # ==============================================================
# # SAC TEST (SESUAI PAPER)
# # ==============================================================
# elif menu == "SAC Test (Paper)":
#     st.title("🎯 SAC Test (Strict Avalanche Criterion)")
#
#     st.markdown("""
#
#
#     Test ini berbeda dengan Avalanche Effect sederhana:
#     - ✅ Test **256 kombinasi input** (0x00 sampai 0xFF)
#     - ✅ Flip **setiap bit** (8 bit) di tiap input
#     - ✅ Hitung pengaruh ke **setiap bit output** (8 bit)
#     - ✅ Generate **SAC Matrix 8×8** (seperti Table 17 paper)
#     - ✅ Ideal SAC value = **0.5** (50%)
#
#     **Paper result:**
#     - AES Standard: 0.50488
#     - SBOX44: **0.50073** ✨ (lebih baik!)
#     """)
#
#     st.markdown("---")
#
#     # Tabs untuk Single Test dan Bulk Test
#     tab1, tab2 = st.tabs(["🔍 Single Key Test", "📊 Bulk SAC Test"])
#
#     # ========== SINGLE KEY TEST ==========
#     with tab1:
#         st.subheader("SAC Test dengan 1 Key")
#
#         col1, col2 = st.columns([1, 2])
#
#         with col1:
#             st.markdown("**Konfigurasi**")
#
#             key_sac = st.text_input(
#                 "Key (16 karakter):",
#                 value=st.session_state.get("key", "1234567890ABCDEF"),
#                 max_chars=16,
#                 key="key_sac"
#             )
#
#             st.info("ℹ️ Test akan menjalankan 256 × 8 = 2,048 enkripsi")
#
#             run_sac = st.button("🚀 Run SAC Test", use_container_width=True)
#
#         with col2:
#             if run_sac:
#                 if len(key_sac) != 16:
#                     st.error("❌ Key harus tepat 16 karakter!")
#                 else:
#                     with st.spinner("Menjalankan SAC test (2048 enkripsi)..."):
#                         key_bytes = key_sac.encode('utf-8')
#
#                         # Test AES Standard
#                         sac_matrix_std, sac_value_std = sac.calculate_sac_for_sbox(
#                             cc.aes_encrypt_block_std,
#                             key_bytes
#                         )
#
#                         # Test SBOX44
#                         sac_matrix_44, sac_value_44 = sac.calculate_sac_for_sbox(
#                             cc.aes_encrypt_block_44,
#                             key_bytes
#                         )
#
#                     st.success("✅ SAC Test selesai!")
#
#                     # Tabel hasil
#                     st.markdown("### 📈 Hasil SAC Value")
#
#                     results_df = pd.DataFrame({
#                         "Algoritma": ["AES Standard", "SBOX44", "Paper (AES)", "Paper (SBOX44)"],
#                         "SAC Value": [
#                             f"{sac_value_std:.5f}",
#                             f"{sac_value_44:.5f}",
#                             "0.50488",
#                             "0.50073"
#                         ],
#                         "Deviasi dari 0.5": [
#                             f"{abs(sac_value_std - 0.5):.5f}",
#                             f"{abs(sac_value_44 - 0.5):.5f}",
#                             "0.00488",
#                             "0.00073"
#                         ]
#                     })
#
#                     st.dataframe(results_df, use_container_width=True)
#
#                     # Winner
#                     st.markdown("### 🏆 Winner")
#                     if abs(sac_value_44 - 0.5) < abs(sac_value_std - 0.5):
#                         improvement = ((abs(sac_value_std - 0.5) - abs(sac_value_44 - 0.5)) / abs(sac_value_44 - 0.5)) * 100
#                         st.success(f"**SBOX44 menang!** Lebih dekat ke ideal 0.5 dengan improvement {improvement:.3f}%")
#                     else:
#                         st.info("AES Standard lebih dekat ke ideal 0.5")
#
#                     # Visualisasi SAC Matrix
#                     st.markdown("### 📊 SAC Matrix 8×8 (Heatmap)")
#
#                     col_a, col_b = st.columns(2)
#
#                     with col_a:
#                         st.markdown("**AES Standard**")
#                         fig_std = go.Figure(data=go.Heatmap(
#                             z=sac_matrix_std,
#                             colorscale='RdYlGn',
#                             zmid=0.5,
#                             text=np.round(sac_matrix_std, 3),
#                             texttemplate='%{text}',
#                             textfont={"size": 10},
#                             colorbar=dict(title="Probability")
#                         ))
#                         fig_std.update_layout(
#                             xaxis_title="Output Bit",
#                             yaxis_title="Input Bit Flipped",
#                             height=400
#                         )
#                         st.plotly_chart(fig_std, use_container_width=True)
#
#                     with col_b:
#                         st.markdown("**SBOX44**")
#                         fig_44 = go.Figure(data=go.Heatmap(
#                             z=sac_matrix_44,
#                             colorscale='RdYlGn',
#                             zmid=0.5,
#                             text=np.round(sac_matrix_44, 3),
#                             texttemplate='%{text}',
#                             textfont={"size": 10},
#                             colorbar=dict(title="Probability")
#                         ))
#                         fig_44.update_layout(
#                             xaxis_title="Output Bit",
#                             yaxis_title="Input Bit Flipped",
#                             height=400
#                         )
#                         st.plotly_chart(fig_44, use_container_width=True)
#
#                     # Detail Matrix
#                     with st.expander("📋 Detail SAC Matrix (Tabel)"):
#                         st.markdown("**AES Standard SAC Matrix:**")
#                         st.dataframe(pd.DataFrame(sac_matrix_std), use_container_width=True)
#
#                         st.markdown("**SBOX44 SAC Matrix:**")
#                         st.dataframe(pd.DataFrame(sac_matrix_44), use_container_width=True)
#
#     # ========== BULK SAC TEST ==========
#     with tab2:
#         st.subheader("Bulk SAC Test dengan Multiple Keys")
#
#         col1, col2 = st.columns([1, 2])
#
#         with col1:
#             st.markdown("**Konfigurasi**")
#
#             n_keys = st.slider(
#                 "Jumlah Random Keys:",
#                 min_value=5,
#                 max_value=100,
#                 value=20,
#                 step=5,
#                 help="Semakin banyak keys = semakin akurat, tapi lebih lama"
#             )
#
#             total_tests = n_keys * 2048
#             st.info(f"📝 Total: {total_tests:,} enkripsi ({n_keys} keys × 2,048)")
#
#             run_bulk_sac = st.button("🚀 Run Bulk SAC Test", use_container_width=True)
#
#         with col2:
#             if run_bulk_sac:
#                 progress_bar = st.progress(0)
#                 status_text = st.empty()
#
#                 import random
#                 import string
#
#                 sac_values_std = []
#                 sac_values_44 = []
#
#                 for i in range(n_keys):
#                     status_text.text(f"Testing key {i+1}/{n_keys}...")
#
#                     # Generate random key
#                     key_str = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(16))
#                     key_bytes = key_str.encode('utf-8')
#
#                     # Test SAC
#                     _, sac_std = sac.calculate_sac_for_sbox(cc.aes_encrypt_block_std, key_bytes)
#                     _, sac_44 = sac.calculate_sac_for_sbox(cc.aes_encrypt_block_44, key_bytes)
#
#                     sac_values_std.append(sac_std)
#                     sac_values_44.append(sac_44)
#
#                     progress_bar.progress((i + 1) / n_keys)
#
#                 progress_bar.empty()
#                 status_text.empty()
#
#                 # Hitung statistik
#                 avg_std = sum(sac_values_std) / len(sac_values_std)
#                 avg_44 = sum(sac_values_44) / len(sac_values_44)
#
#                 st.success(f"✅ Selesai! {n_keys} keys berhasil ditest")
#
#                 # Tabel statistik
#                 st.markdown("### 📈 Hasil Statistik")
#
#                 stats_df = pd.DataFrame({
#                     "Metric": ["Mean SAC", "Min SAC", "Max SAC", "Deviation from 0.5", "Paper Value"],
#                     "AES Standard": [
#                         f"{avg_std:.5f}",
#                         f"{min(sac_values_std):.5f}",
#                         f"{max(sac_values_std):.5f}",
#                         f"{abs(avg_std - 0.5):.5f}",
#                         "0.50488"
#                     ],
#                     "SBOX44": [
#                         f"{avg_44:.5f}",
#                         f"{min(sac_values_44):.5f}",
#                         f"{max(sac_values_44):.5f}",
#                         f"{abs(avg_44 - 0.5):.5f}",
#                         "0.50073"
#                     ]
#                 })
#
#                 st.dataframe(stats_df, use_container_width=True)
#
#                 # Visualisasi distribusi
#                 st.markdown("### 📊 Distribusi SAC Values")
#
#                 fig = make_subplots(
#                     rows=1, cols=2,
#                     subplot_titles=("AES Standard", "SBOX44")
#                 )
#
#                 # Histogram AES Standard
#                 fig.add_trace(
#                     go.Histogram(
#                         x=sac_values_std,
#                         name="AES Std",
#                         marker_color='#3498db',
#                         nbinsx=15
#                     ),
#                     row=1, col=1
#                 )
#
#                 # Histogram SBOX44
#                 fig.add_trace(
#                     go.Histogram(
#                         x=sac_values_44,
#                         name="SBOX44",
#                         marker_color='#e74c3c',
#                         nbinsx=15
#                     ),
#                     row=1, col=2
#                 )
#
#                 # Garis ideal (0.5)
#                 fig.add_vline(x=0.5, line_dash="dash", line_color="green",
#                               annotation_text="Ideal: 0.5", row=1, col=1)
#                 fig.add_vline(x=0.5, line_dash="dash", line_color="green",
#                               annotation_text="Ideal: 0.5", row=1, col=2)
#
#                 fig.update_xaxes(title_text="SAC Value", row=1, col=1)
#                 fig.update_xaxes(title_text="SAC Value", row=1, col=2)
#                 fig.update_yaxes(title_text="Frequency", row=1, col=1)
#
#                 fig.update_layout(height=400, showlegend=False)
#
#                 st.plotly_chart(fig, use_container_width=True)
#
#                 # Kesimpulan
#                 st.markdown("### 🎯 Kesimpulan")
#
#                 if abs(avg_44 - 0.5) < abs(avg_std - 0.5):
#                     improvement = ((abs(avg_std - 0.5) - abs(avg_44 - 0.5)) / abs(avg_44 - 0.5)) * 100
#                     st.success(f"""
#                     **🏆 WINNER: SBOX44**
#
#                     SBOX44 memiliki SAC value **{avg_44:.5f}** (deviasi: {abs(avg_44 - 0.5):.5f})
#
#                     AES Standard memiliki SAC value **{avg_std:.5f}** (deviasi: {abs(avg_std - 0.5):.5f})
#
#                     **Improvement: {improvement:.3f}%** ✨
#
#                     Hasil ini **konsisten dengan paper** Pak Alam!
#                     """)
#                 else:
#                     st.info(f"""
#                     **AES Standard lebih baik** (SAC: {avg_std:.5f}, deviasi: {abs(avg_std - 0.5):.5f})
#
#                     vs SBOX44 (SAC: {avg_44:.5f}, deviasi: {abs(avg_44 - 0.5):.5f})
#                     """)
#
#
# # ==============================================================
# # BULK TEST ANALYSIS
# # ==============================================================
# elif menu == "Bulk Test Analysis":
#     st.title("📊 Bulk Test Analysis")
#
#     st.markdown("""
#     **Bulk Testing** menjalankan ratusan tes dengan kombinasi plaintext dan key yang berbeda-beda.
#
#     Ini memberikan gambaran statistik yang lebih akurat tentang performa algoritma,
#     karena hasil dari 1 sample saja bisa tidak representatif.
#     """)
#
#     st.markdown("---")
#
#     # Tabs untuk Avalanche dan Key Sensitivity
#     tab1, tab2 = st.tabs(["⚡ Bulk Avalanche Test", "🔑 Bulk Key Sensitivity Test"])
#
#     # ========== BULK AVALANCHE TEST ==========
#     with tab1:
#         st.subheader("Bulk Avalanche Effect Testing")
#
#         col1, col2 = st.columns([1, 2])
#
#         with col1:
#             st.markdown("**Konfigurasi Test**")
#
#             n_samples_av = st.slider(
#                 "Jumlah Sampel:",
#                 min_value=10,
#                 max_value=500,
#                 value=100,
#                 step=10,
#                 help="Semakin banyak sampel = semakin akurat, tapi lebih lama"
#             )
#
#             st.info(f"📝 Akan menguji {n_samples_av} kombinasi plaintext-key yang berbeda")
#
#             run_bulk_av = st.button("🚀 Jalankan Bulk Test", use_container_width=True, key="bulk_av")
#
#         with col2:
#             if run_bulk_av:
#                 # Progress bar
#                 progress_bar = st.progress(0)
#                 status_text = st.empty()
#
#                 def update_progress(pct):
#                     progress_bar.progress(pct)
#                     status_text.text(f"Testing... {int(pct*100)}% selesai")
#
#                 with st.spinner("Menjalankan bulk testing..."):
#                     results = at.run_bulk_avalanche_test(n_samples_av, update_progress)
#
#                 progress_bar.empty()
#                 status_text.empty()
#
#                 if results:
#                     st.success(f"✅ Selesai! {results['n_samples']} sampel berhasil diuji")
#
#                     # Tabel statistik
#                     st.markdown("### 📈 Hasil Statistik")
#
#                     stats_df = pd.DataFrame({
#                         "Metric": ["Mean (%)", "Min (%)", "Max (%)", "Deviation from 50%", "Quality Rating"],
#                         "AES Standard": [
#                             f"{results['std']['mean']:.2f}",
#                             f"{results['std']['min']:.2f}",
#                             f"{results['std']['max']:.2f}",
#                             f"{abs(results['std']['mean'] - 50):.3f}",
#                             at.get_quality_rating(results['std']['mean'])
#                         ],
#                         "AES SBOX44": [
#                             f"{results['sbox44']['mean']:.2f}",
#                             f"{results['sbox44']['min']:.2f}",
#                             f"{results['sbox44']['max']:.2f}",
#                             f"{abs(results['sbox44']['mean'] - 50):.3f}",
#                             at.get_quality_rating(results['sbox44']['mean'])
#                         ]
#                     })
#
#                     st.dataframe(stats_df, use_container_width=True)
#
#                     # Visualisasi distribusi
#                     st.markdown("### 📊 Distribusi Hasil")
#
#                     fig = make_subplots(
#                         rows=1, cols=2,
#                         subplot_titles=("AES Standard", "AES SBOX44")
#                     )
#
#                     # Histogram AES Standard
#                     fig.add_trace(
#                         go.Histogram(
#                             x=results['std']['all_values'],
#                             name="AES Std",
#                             marker_color='#3498db',
#                             nbinsx=20
#                         ),
#                         row=1, col=1
#                     )
#
#                     # Histogram SBOX44
#                     fig.add_trace(
#                         go.Histogram(
#                             x=results['sbox44']['all_values'],
#                             name="SBOX44",
#                             marker_color='#e74c3c',
#                             nbinsx=20
#                         ),
#                         row=1, col=2
#                     )
#
#                     # Garis ideal (50%)
#                     fig.add_hline(y=0, line_dash="dash", line_color="green",
#                                   annotation_text="Ideal: 50%", row=1, col=1)
#                     fig.add_hline(y=0, line_dash="dash", line_color="green",
#                                   annotation_text="Ideal: 50%", row=1, col=2)
#
#                     fig.update_xaxes(title_text="Percentage (%)", row=1, col=1)
#                     fig.update_xaxes(title_text="Percentage (%)", row=1, col=2)
#                     fig.update_yaxes(title_text="Frequency", row=1, col=1)
#
#                     fig.update_layout(height=400, showlegend=False)
#
#                     st.plotly_chart(fig, use_container_width=True)
#
#                     # Kesimpulan
#                     st.markdown("### 🎯 Kesimpulan")
#
#                     winner = "AES SBOX44" if abs(results['sbox44']['mean'] - 50) < abs(results['std']['mean'] - 50) else "AES Standard"
#                     diff = abs(abs(results['sbox44']['mean'] - 50) - abs(results['std']['mean'] - 50))
#
#                     st.info(f"""
#                     **Winner:** {winner} ✨
#
#                     **SBOX44** memiliki deviasi dari ideal (50%) sebesar **{abs(results['sbox44']['mean'] - 50):.3f}%**
#
#                     **AES Standard** memiliki deviasi sebesar **{abs(results['std']['mean'] - 50):.3f}%**
#
#                     Selisih: **{diff:.3f}%**
#                     """)
#
#                 else:
#                     st.error("❌ Terjadi kesalahan saat menjalankan bulk test")
#
#     # ========== BULK KEY SENSITIVITY TEST ==========
#     with tab2:
#         st.subheader("Bulk Key Sensitivity Testing")
#
#         col1, col2 = st.columns([1, 2])
#
#         with col1:
#             st.markdown("**Konfigurasi Test**")
#
#             n_samples_ks = st.slider(
#                 "Jumlah Sampel:",
#                 min_value=10,
#                 max_value=500,
#                 value=100,
#                 step=10,
#                 help="Semakin banyak sampel = semakin akurat, tapi lebih lama",
#                 key="n_samples_ks"
#             )
#
#             st.info(f"📝 Akan menguji {n_samples_ks} kombinasi plaintext-key yang berbeda")
#
#             run_bulk_ks = st.button("🚀 Jalankan Bulk Test", use_container_width=True, key="bulk_ks")
#
#         with col2:
#             if run_bulk_ks:
#                 # Progress bar
#                 progress_bar = st.progress(0)
#                 status_text = st.empty()
#
#                 def update_progress(pct):
#                     progress_bar.progress(pct)
#                     status_text.text(f"Testing... {int(pct*100)}% selesai")
#
#                 with st.spinner("Menjalankan bulk testing..."):
#                     results = at.run_bulk_key_sensitivity_test(n_samples_ks, update_progress)
#
#                 progress_bar.empty()
#                 status_text.empty()
#
#                 if results:
#                     st.success(f"✅ Selesai! {results['n_samples']} sampel berhasil diuji")
#
#                     # Tabel statistik
#                     st.markdown("### 📈 Hasil Statistik")
#
#                     stats_df = pd.DataFrame({
#                         "Metric": ["Mean (%)", "Min (%)", "Max (%)", "Deviation from 50%", "Quality Rating"],
#                         "AES Standard": [
#                             f"{results['std']['mean']:.2f}",
#                             f"{results['std']['min']:.2f}",
#                             f"{results['std']['max']:.2f}",
#                             f"{abs(results['std']['mean'] - 50):.3f}",
#                             at.get_quality_rating(results['std']['mean'])
#                         ],
#                         "AES SBOX44": [
#                             f"{results['sbox44']['mean']:.2f}",
#                             f"{results['sbox44']['min']:.2f}",
#                             f"{results['sbox44']['max']:.2f}",
#                             f"{abs(results['sbox44']['mean'] - 50):.3f}",
#                             at.get_quality_rating(results['sbox44']['mean'])
#                         ]
#                     })
#
#                     st.dataframe(stats_df, use_container_width=True)
#
#                     # Visualisasi distribusi
#                     st.markdown("### 📊 Distribusi Hasil")
#
#                     fig = make_subplots(
#                         rows=1, cols=2,
#                         subplot_titles=("AES Standard", "AES SBOX44")
#                     )
#
#                     # Histogram AES Standard
#                     fig.add_trace(
#                         go.Histogram(
#                             x=results['std']['all_values'],
#                             name="AES Std",
#                             marker_color='#3498db',
#                             nbinsx=20
#                         ),
#                         row=1, col=1
#                     )
#
#                     # Histogram SBOX44
#                     fig.add_trace(
#                         go.Histogram(
#                             x=results['sbox44']['all_values'],
#                             name="SBOX44",
#                             marker_color='#e74c3c',
#                             nbinsx=20
#                         ),
#                         row=1, col=2
#                     )
#
#                     fig.update_xaxes(title_text="Percentage (%)", row=1, col=1)
#                     fig.update_xaxes(title_text="Percentage (%)", row=1, col=2)
#                     fig.update_yaxes(title_text="Frequency", row=1, col=1)
#
#                     fig.update_layout(height=400, showlegend=False)
#
#                     st.plotly_chart(fig, use_container_width=True)
#
#                     # Kesimpulan
#                     st.markdown("### 🎯 Kesimpulan")
#
#                     winner = "AES SBOX44" if abs(results['sbox44']['mean'] - 50) < abs(results['std']['mean'] - 50) else "AES Standard"
#                     diff = abs(abs(results['sbox44']['mean'] - 50) - abs(results['std']['mean'] - 50))
#
#                     st.info(f"""
#                     **Winner:** {winner} ✨
#
#                     **SBOX44** memiliki deviasi dari ideal (50%) sebesar **{abs(results['sbox44']['mean'] - 50):.3f}%**
#
#                     **AES Standard** memiliki deviasi sebesar **{abs(results['std']['mean'] - 50):.3f}%**
#
#                     Selisih: **{diff:.3f}%**
#                     """)
#
#                 else:
#                     st.error("❌ Terjadi kesalahan saat menjalankan bulk test")
#
#
# # Footer
# st.markdown("---")
# st.caption("🔐 AES vs SBOX44 Analyzer | Cryptographic Analysis Tool")

# # !pip install streamlit pyngrok

# from pyngrok import ngrok

# # ==============================
# # MASUKKAN TOKEN NGROK DI SINI
# # ==============================
# NGROK_TOKEN = "36E8eZt6W9ghL0zPujVrC0lIVha_673xyseh7z6N34pZsdM14"  # <--- GANTI DENGAN TOKENMU
# ngrok.set_auth_token(NGROK_TOKEN)

# # Tutup tunnel lama kalau ada
# ngrok.kill()

# import subprocess
# import time

# port = 8501

# # Jalankan streamlit
# process = subprocess.Popen(["streamlit", "run", "app.py"], stdout=subprocess.PIPE)

# # Tunggu server siap
# time.sleep(3)

# # Buka tunnel publik
# public_url = ngrok.connect(port).public_url
# print("Akses Streamlit di URL berikut:")
# print(public_url)



